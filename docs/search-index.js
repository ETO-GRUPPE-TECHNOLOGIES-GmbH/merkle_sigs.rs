var searchIndex = {};
searchIndex["merkle_sigs"] = {"doc":"`merkle_sigs` implements Merkle signatures in Rust.","items":[[3,"Proof","merkle_sigs","An inclusion proof represent the fact that a `value` is a member\nof a `MerkleTree` with root hash `root_hash`, and hash function `algorithm`.",null,null],[12,"algorithm","","The hashing algorithm used in the original `MerkleTree`",0,null],[12,"root_hash","","The hash of the root of the original `MerkleTree`",0,null],[12,"lemma","","The first `Lemma` of the `Proof`",0,null],[12,"value","","The value concerned by this `Proof`",0,null],[3,"PublicKey","","A one-time signing public key",null,null],[5,"verify_data_vec_signature","","Verifies the signature of the data. Returns an error if data couldn&#39;t be verified.",null,{"inputs":[{"name":"t"},{"name":"merklesignature"},{"name":"vec"}],"output":{"name":"result"}}],[5,"sign_data_vec","","Signs the entries of the data vector",null,{"inputs":[{"name":"vec"},{"name":"algorithm"}],"output":{"name":"result"}}],[6,"MerkleSignature","","A type alias defining a Merkle signature. That includes both the Lamport leaf signature and inclusion proof.",null,null],[6,"MerkleSignedData","","A type alias defining Merkle signed data. That includes the data being signed along with the signature.",null,null],[11,"new","","Constructs a new `Proof`",0,{"inputs":[{"name":"algorithm"},{"name":"vec"},{"name":"lemma"},{"name":"t"}],"output":{"name":"proof"}}],[11,"validate","","Checks whether this inclusion proof is well-formed,\nand whether its root hash matches the given `root_hash`.",0,null],[11,"from_protobuf","","Constructs a `Proof` struct from its Protobuf representation.",0,{"inputs":[{"name":"algorithm"},{"name":"proofproto"}],"output":{"name":"option"}}],[11,"into_protobuf","","Encode this `Proof` to its Protobuf representation.",0,null],[11,"parse_from_bytes","","Parse a `Proof` from its Protobuf binary representation.",0,null],[11,"write_to_bytes","","Serialize this `Proof` with Protobuf.",0,null],[11,"fmt","","",0,null],[11,"clone","","",0,null],[11,"hash","","",1,null],[11,"eq","","",1,null],[11,"fmt","","",1,null],[11,"clone","","",1,null],[11,"from_vec","","Intializes a public key with a byte vector.\nReturns `None` if it couldn&#39;t parse the provided data",1,{"inputs":[{"name":"vec"},{"name":"algorithm"}],"output":{"name":"option"}}],[11,"to_bytes","","Serializes a public key into a byte vector",1,null],[11,"verify_signature","","Verifies that the signature of the data is correctly signed with the given key",1,null]],"paths":[[3,"Proof"],[3,"PublicKey"]]};
initSearch(searchIndex);
